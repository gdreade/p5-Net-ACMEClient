#! /usr/bin/env perl
#
# To read the man page for this script:
#
#    ./acme-client-zoneedit -man
#

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use File::Spec;
use Config::Tiny;

BEGIN {
    # This chunk of code is to allow for the fact that our modules
    # may not be installed in the @INC path; they may be in a ../lib
    # or ../lib/perl5  directory hierarchy if we're running a bundle
    # extracted into an arbitrary directory.
    #
    # We use taint mode and the env(1) indirection to launch the program,
    # so using the -I argument won't work.

    my @mods = ( "Net::ACMEClient::DNS::ZoneEditor",
		 "Net::ACMEClient::DNS"
	);

    for my $mod (@mods) {
	if (! eval "require $mod") {
	    my ($volume, $directory, $file) = File::Spec->splitpath(__FILE__);
	    my $bindir = File::Spec->canonpath($directory);
	    my $libdir = File::Spec->catdir($bindir,
					    File::Spec->updir,
					    "lib");
	    my $perldir = File::Spec->catdir($libdir, "perl5");
	    
	    if ($libdir =~ m,^(.*)$,) {
		my $untainted = $1;
		unshift(@INC, $untainted)
		    || die "couldn't unshift lib directory";
	    }

	    if ($perldir =~ m,^(.*)$,) {
		my $untainted = $1;
		unshift(@INC, $untainted)
		    || die "couldn't unshift perl directory";
	    }
	    eval "require $mod" or die "couldn't find module $mod: $!";
	}
	$mod->import();
    }
}

use Net::ACMEClient::DNS::ZoneEditor qw(:macros);

# Enable taint mode
# warn 'Taint mode is '.(${^TAINT} ? 'on' : 'off'); # For debugging
exec($^X,'-T',$0,@ARGV) unless ${^TAINT};

# sanitize $PATH and clean up %ENV
local $ENV{PATH} = "/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin"
    . ":/usr/local/bin" . "";
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

my $config; # the parsed configuration

# command line options
my ($man, $help);
my ($fqdn, $challenge, $encoded_challenge);
my $wait;
my $config_file = '/usr/local/etc/acme-client-zoneedit.conf';

# defaults to be overridden in config file
my $use_syslog = 1;
my $use_dnssec = 1;
my $debug_queries = 0;
my $use_ipv4 = 1;
my $use_ipv6 = 1;
my $challenge_ttl = DEFAULT_CHALLENGE_TTL;
my $challenge_suffix = DEFAULT_CHALLENGE_SUFFIX;
my $new_file_suffix = DEFAULT_NEW_FILE_SUFFIX;
my $old_file_suffix = DEFAULT_OLD_FILE_SUFFIX;
my $soa_suffix = DEFAULT_SOA_SUFFIX;

Getopt::Long::Configure ("bundling", "no_ignore_case");
GetOptions("man" => \$man,
	   "help|h" => \$help,
	   "fqdn=s" => \$fqdn,
	   "challenge=s" => \$challenge,
	   "encoded-challenge=s" => \$encoded_challenge,
	   "config|c=s" => \$config_file,
	   "wait|w" => \$wait)
    || pod2usage(2);
	   
#
# evaluate options
#
pod2usage(1) if defined($help);
pod2usage(-exitval => 0, -verbose => 2) if defined($man);

&read_config;

# conchecks

my $four_or_six = undef;
if ($use_ipv4 && !$use_ipv6) {
    $four_or_six = Net::ACMEClient::DNS->IPV4_ONLY;
} elsif (!$use_ipv4 && $use_ipv6) {
    $four_or_six = Net::ACMEClient::DNS->IPV6_ONLY;
} elsif (!$use_ipv4 && !$use_ipv6) {
    fatal("at least one of IPv4 or IPv6 must be enabled");
}

if (defined($fqdn) || defined($challenge) || defined($encoded_challenge)) {
    if (!defined($fqdn)) {
	fatal("--fqdn must be specified when either --challenge or "
	      . "--encoded-challenge is given");
    }
    if (!defined($challenge) && !defined($encoded_challenge)) {
	fatal("at least one of --challenge or --encoded-challenge must be "
	      . "specified when using --fqdn");
    }
    if (defined($challenge) && defined($encoded_challenge)) {
	fatal("only one of --challenge or --encoded-challenge may be "
	      . "specified when using --fqdn");
    }
    if (defined($challenge)) {
	$encoded_challenge = 
	    Net::ACMEClient::DNS->encode_challenge($challenge);
    }

    

    printf (STDERR "fqdn: %s encoded challenge: %s\n", $fqdn, $encoded_challenge);
}


# logic begins
if (defined($fqdn)) {
    my $ret = &process_challenge;
    exit($ret);
}

#my $fqdn = 'www.example.com';
#my $challenge = 'the_cha.ll77enge';

#my $fqdn = 'www.cydonia.ca';
#my $challenge = 'fbJ0HWRdI_bBSGrUvJc-6GIwhrmyHDDCPRzDNtqvP1A';

exit(0);


sub process_challenge {
    # get parameters from config
    my $query_timeout = Net::ACMEClient::DNS->DEFAULT_PROPAGATION_TIMEOUT;
    my $v = $config->{$fqdn}->{query_timeout};
    defined($v) && (int($v) > 0) && ($query_timeout = int($v));

    my $section = $config->{$fqdn};
    defined($section) ||  fatal("no section for $fqdn was found in " .
				 "configuration file $config_file");

    my $base_name = $section->{base_name};
    defined($base_name) || fatal("base_name was not set in the [$fqdn] " .
				 "section of $config_file");

    my $nameservers = undef;
    my $nameserver_list = $section->{nameservers};
    if (defined($nameserver_list)) {
	my @ns = split /\s+/, $nameserver_list;
	if (scalar(@ns) > 0) {
	    $nameservers = \@ns;
	}
    }

    my $host_suffix = $section->{host_suffix};
    if (!defined($host_suffix) || (length($host_suffix) == 0)) {
	# assume that we can use the first component of the fqdn
	if ($fqdn =~ m,^([a-z0-9]+),) {
	    $host_suffix = $1;
	} else {
	    fatal("in section [$fqdn] of $config_file host_suffix was not ".
		  "set and could not be inferred");
	}
    }

    # do the work
    my $dns = Net::ACMEClient::DNS->new(debug_queries => $debug_queries,
					four_or_six => $four_or_six,
					use_dnssec => $use_dnssec,
					use_syslog => $use_syslog);

    my $editor = Net::ACMEClient::DNS::ZoneEditor->new(
	base_name => $base_name,
	challenge_suffix => $challenge_suffix,
	challenge_ttl => $challenge_ttl,
	new_file_suffix => $new_file_suffix,
	old_file_suffix => $old_file_suffix,
	soa_suffix => $soa_suffix
    );

    $editor->write_challenge($fqdn, $encoded_challenge, $host_suffix)
	|| die "failed to write challenge file for $fqdn";
    $editor->increment_soa || die "failed to increment SOA serial for $fqdn";
    
    # TODO need reload next

    if (0) {
    $dns->wait_for_challenge_propagation($fqdn, $challenge, $query_timeout,
					 $nameservers)
	or die "challenges failed to appear for $fqdn on configured DNS "
	. "servers within the configured timeout";

    }
    
    1;
}

sub read_config {
    $config = Config::Tiny->read($config_file)
	or die "failed to read configuration file $config_file";

    my $v = $config->{_}->{use_syslog};
    defined($v) && ($use_syslog = $v);

    $v = $config->{_}->{use_dnssec};
    defined($v) && ($use_dnssec = $v);

    $v = $config->{_}->{debug_queries};
    defined($v) && ($debug_queries = $v);

    $v = $config->{_}->{use_ipv4};
    defined($v) && ($use_ipv4 = $v);

    $v = $config->{_}->{use_ipv6};
    defined($v) && ($use_ipv6 = $v);

    $v = $config->{_}->{challenge_ttl};
    defined($v) && (int($v) > 0) && ($challenge_ttl = $v);

    $v = $config->{_}->{challenge_suffix};
    defined($v) && ($challenge_suffix = $v);

    $v = $config->{_}->{new_file_suffix};
    defined($v) && (length($v) > 0) && ($new_file_suffix = $v);

    $v = $config->{_}->{old_file_suffix};
    defined($v) && (length($v) > 0) && ($old_file_suffix = $v);

    $v = $config->{_}->{soa_suffix};
    defined($v) && (length($v) > 0) && ($soa_suffix = $v);
    
    1;
}

sub fatal {
    my $msg = shift;
    printf(STDERR "%s\n", $msg);
    exit(1);
}

my $editor = Net::ACMEClient::DNS::ZoneEditor->new(
    base_name => '/tmp/acme.example.com'
    );

#my $ret = $editor->run(\@ARGV);

my $ret;

#my $ret = $editor->write_challenge($fqdn, $challenge, 'www');
#($ret) || die "write_challenge failed";

# $editor->increment_soa || die "failed to increment SOA";

if (1) {
    my $dns = Net::ACMEClient::DNS->new(use_syslog => 1, debug_queries => 0);

    my $dns_servers = undef;

    if (1) {
    $dns->wait_for_challenge_propagation($fqdn, $challenge, undef,
					 $dns_servers)
	or die "challenges failed to appear on configured DNS servers within "
	. "the configured timeout";
    }

}

if (0) {
    my $dns = Net::ACMEClient::DNS->new(use_syslog => 1, debug_queries => 0,
					four_or_six => 
					Net::ACMEClient::DNS->IPV4_ONLY);

    my $tries = [ 'nothing.example.com' ];
    foreach my $try (@$tries) {
	my $ret = $dns->lookup_nameservers($try);
	defined($ret) || die "lookup failed for $try";

	foreach my $ns (@$ret) {
	    print STDERR "for $try found nameserver $ns\n";
	}
    }
    
}
exit(0);

__END__

=head1 NAME

acme-client-zoneedit - Zone editing helper for acme-client(1)

=head1 SYNOPSIS

acme-client_zoneedit --man

acme-client_zoneedit --fqdn FQDN --challenge CHALLENGE

acme-client_zoneedit [options] domain [altname ...]

=head1 DESCRIPTION

B<acme-client_zoneedit> ... does something


=head1 OPTIONS

Write something here.  Also:

=over 8

=item B<--help>

Print a brief help message and exit.

=item B<--man>

Print the manual page and exit.

=item B<--fqdn>

The fully qualified domain name of the host for which a challenge 
should be added or updated.  If provided, then exactly one of
B<--challenge> or B<--encoded-challenge> must also be provided.

=item B<--challenge>=I<value> | B<-c>I<value>

Specify the raw challenge as provided by B<acme-client>(1).

Be aware that using this flag can expose the host key in the process table
or shell history.  If that is an issue, you may want to consider using
the B<--encoded-challenge> flag.

If this option is specified, then B<--fqdn> must also be specified.

=item B<--encoded-challenge>=I<value> | B<-e>I<value>

Specify the encoded challenge to use.

If this option is specified, then B<--fqdn> must also be specified.

=back

=head1 SEE ALSO

Net::ACMEClient::DNS(3pm),
acme-client(1)

=head1 AUTHOR

Devin Reade <gdr@gno.org>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2017 by Devin Reade

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.1 or,
at your option, any later version of Perl 5 you may have available.

=cut
